# adapted from lambdasoc
# https://github.com/lambdaconcept/lambdasoc
# originally under a BSD 2-Clause "Simplified" License, (c) 2020 LambdaConcept

# modified to rely on add_file rather than module magic for blackboxes
# and other minor, petty things like s/.cc/.cpp/

import importlib

import amaranth as am
import amaranth.build

class CxxRtlPlatform(am.build.TemplatedPlatform):
    device      = "cxxrtl"
    default_clk = "clk"
    default_rst = "rst"
    resources   = [
        am.build.Resource("clk", 0, am.build.Pins("clk", dir="i"), am.build.Clock(5e6)),
        am.build.Resource("rst", 0, am.build.Pins("rst", dir="i")),
    ]
    connectors  = []
    toolchain   = None # selected when creating platform

    file_templates = {
        **am.build.TemplatedPlatform.build_script_templates,
        "{{name}}.il": r"""
            # {{autogenerated}}
            {{emit_rtlil()}}
        """,
        "{{name}}.ys": r"""
            # {{autogenerated}}
            {% for file in platform.iter_files(".v") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".sv") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".il") -%}
                read_rtlil {{file}}
            {% endfor %}
            read_rtlil {{name}}.il
            delete w:$verilog_initial_trigger
            select {{name}}
            select -add =cxxrtl_*
            {{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
            write_cxxrtl {{get_override("write_cxxrtl_opts")|options}} -print-output std::cerr -header {{name}}.cpp
        """,
        "{{name}}.mk": r"""
            # {{autogenerated}}
            YOSYS ?= yosys
            YOSYS_CONFIG ?= yosys-config
            CC       = $(CXX)
            CPPFLAGS = -include {{name}}.h -MMD \
                       -I{{get_override("yosys_include_dir")|default("$(shell $(YOSYS_CONFIG) --datdir)/include/backends/cxxrtl/runtime")}} \
                       {{get_override("additional_cpp_flags")|default("# (additional_cpp_flags placeholder)")}}
            CXXFLAGS = {{get_override("cxx_flags")|default("-std=c++14 -Wall -O3 -mtune=native")}}
            LDFLAGS  = {{get_override("ld_flags")|default("# (ld_flags placeholder)")}}
            LDLIBS   = {{get_override("ld_libs")|default("# (ld_libs placeholder)")}}

            SRC  = {{name}}.cpp \
            {% for file in platform.iter_files(".cpp") %}
                   {{file}} \
            {% endfor %}

            OBJS = $(SRC:.cpp=.o)
            DEPS = $(OBJS:.o=.d)

            .PHONY: all clean

            all: {{name}}

            -include DEPS

            {% set tab = ""|indent(width="\t", first=True) -%}

            {% for file in platform.iter_files(".v", ".sv", ".il") %}
            {{name}}.cpp {{name}}.h: {{file}}
            {% endfor %}
            {{name}}.cpp {{name}}.h: {{name}}.ys {{name}}.il
            {{tab}}$(YOSYS) -s {{name}}.ys

            $(OBJS): {{name}}.h

            {{name}}: $(OBJS)

            clean:
            {{tab}}rm -f {{name}}.cpp {{name}}.h
            {{tab}}rm -f $(OBJS) $(DEPS)
            {{tab}}rm -f {{name}}
        """,
    }

    # GCC templates

    _gcc_required_tools = [
        "yosys",
        "yosys-config",
        "g++",
        "make",
    ]
    _gcc_command_templates = [
        r"""
            YOSYS={{invoke_tool("yosys")}}
            YOSYS_CONFIG={{invoke_tool("yosys-config")}}
            CXX={{invoke_tool("g++")}}
            {{invoke_tool("make")}} -f {{name}}.mk
        """,
    ]

    # Clang templates

    _clang_required_tools = [
        "yosys",
        "yosys-config",
        "clang++",
        "make",
    ]
    _clang_command_templates = [
        r"""
            YOSYS={{invoke_tool("yosys")}}
            YOSYS_CONFIG={{invoke_tool("yosys-config")}}
            CXX={{invoke_tool("clang++")}}
            {{invoke_tool("make")}} -f {{name}}.mk
        """,
    ]

    def __init__(self, *, toolchain="gcc"):
        super().__init__()

        assert toolchain in ("gcc", "clang")
        self.toolchain = toolchain

        self.add_file('cxxrtl/driver.cpp', importlib.resources.files().joinpath('cxxrtl', 'driver.cpp').read_text())

    @property
    def required_tools(self):
        if self.toolchain == "gcc":
            return self._gcc_required_tools
        if self.toolchain == "clang":
            return self._clang_required_tools
        assert False

    @property
    def command_templates(self):
        if self.toolchain == "gcc":
            return self._gcc_command_templates
        if self.toolchain == "clang":
            return self._clang_command_templates
        assert False

    def create_missing_domain(self, name):
        if name == "sync":
            m = am.Module()
            clk_i = self.request(self.default_clk).i
            rst_i = self.request(self.default_rst).i
            m.domains.sync = am.ClockDomain("sync")
            m.d.comb += [
                am.ClockSignal("sync").eq(clk_i),
                am.ResetSignal("sync").eq(rst_i),
            ]
            return m

    class _Pll(am.lib.wiring.Component):
        lock: am.lib.wiring.Out(1, init=1)

        def __init__(self, in_period, out_period, domain):
            self.in_period = in_period
            self.out_period = out_period
            self.domain = domain

            super().__init__()

        def elaborate(self, platform):
            m = am.Module()

            m.d.comb += am.ClockSignal(self.domain).eq(am.ClockSignal())

            return m

    def generate_pll(self, in_period, out_period, domain):
        return self._Pll(in_period, out_period, domain)
